<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>64-Square Tactics v3 (Territory + Battles + Evolutions)</title>
  <style>
    :root{
      --bg:#0b1020; --panel:#0f1733; --card:#141f44;
      --text:#e8eeff; --muted:#9bb0ff; --accent:#7aa2ff;
      --good:#34d399; --warn:#fbbf24; --bad:#fb7185;
    }
    *{box-sizing:border-box; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;}
    body{margin:0; background:radial-gradient(1200px 800px at 20% 10%, #172554, var(--bg)); color:var(--text);}
    .wrap{max-width:1220px; margin:0 auto; padding:18px;}
    .top{display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap;}
    .brand{display:flex; align-items:baseline; gap:10px;}
    .brand h1{margin:0; font-size:22px; letter-spacing:.4px;}
    .brand .tag{font-size:12px; color:var(--muted); opacity:.95;}
    .pillrow{display:flex; gap:10px; flex-wrap:wrap;}
    .pill{background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12); padding:6px 10px; border-radius:999px; font-size:12px; color:#dbe4ff;}
    .panel{margin-top:14px; background:rgba(15,23,51,.75); border:1px solid rgba(255,255,255,.12); border-radius:18px; padding:14px; backdrop-filter: blur(10px);}
    .row{display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap;}
    .help{color:rgba(232,238,255,.78); font-size:13px; line-height:1.35; margin:8px 0 12px;}
    .stage{display:none;}
    .stage.active{display:block;}
    .grid4{display:grid; grid-template-columns:repeat(4,1fr); gap:12px;}
    @media (max-width: 900px){ .grid4{grid-template-columns:repeat(2,1fr);} }
    .card{background:rgba(20,31,68,.92); border:1px solid rgba(255,255,255,.14); border-radius:16px; padding:14px;
      cursor:pointer; transition: transform .12s ease, border-color .12s ease, background .12s ease; min-height:112px;
      display:flex; flex-direction:column; justify-content:space-between;
    }
    .card:hover{transform: translateY(-2px); border-color: rgba(122,162,255,.65);}
    .card.sel{border-color: rgba(52,211,153,.9); box-shadow: 0 0 0 2px rgba(52,211,153,.25) inset;}
    .card h3{margin:0; font-size:15px;}
    .card p{margin:8px 0 0; font-size:12px; color:rgba(232,238,255,.82); line-height:1.25;}
    .btn{appearance:none; border:1px solid rgba(255,255,255,.18); background:rgba(255,255,255,.06);
      color:var(--text); padding:10px 12px; border-radius:12px; cursor:pointer; font-weight:800;
      transition: background .12s ease, transform .12s ease, border-color .12s ease;
    }
    .btn:hover{background:rgba(255,255,255,.10); border-color:rgba(122,162,255,.7)}
    .btn:active{transform: translateY(1px)}
    .btn.primary{background: rgba(122,162,255,.18); border-color: rgba(122,162,255,.55)}
    .btn.primary:hover{background: rgba(122,162,255,.25)}
    .btn.danger{background: rgba(251,113,133,.12); border-color: rgba(251,113,133,.5)}
    .btn:disabled{opacity:.55; cursor:not-allowed;}
    .arena{display:grid; grid-template-columns: 1.05fr .95fr; gap:12px; align-items:start;}
    @media (max-width: 980px){ .arena{grid-template-columns:1fr;} }
    #board{
      width:100%;
      aspect-ratio: 1/1;
      background: radial-gradient(700px 450px at 45% 35%, #0f1b3f, #070b17);
      border-radius:18px;
      border:1px solid rgba(255,255,255,.12);
      display:block;
    }
    .hud{background:rgba(20,31,68,.75); border:1px solid rgba(255,255,255,.12); border-radius:18px; padding:14px;}
    .hud h3{margin:0 0 8px; font-size:15px;}
    .kv{display:grid; grid-template-columns: 170px 1fr; gap:6px 10px; font-size:12px; color:rgba(232,238,255,.85)}
    .kv b{color:var(--muted); font-weight:900;}
    .divider{height:1px; background:rgba(255,255,255,.10); margin:12px 0;}
    .mini{display:flex; gap:8px; flex-wrap:wrap; margin-top:10px;}
    .badge{font-size:12px; padding:6px 10px; border-radius:999px; border:1px solid rgba(255,255,255,.14); background:rgba(255,255,255,.06);}
    .badge.good{border-color: rgba(52,211,153,.45); background:rgba(52,211,153,.10)}
    .badge.warn{border-color: rgba(251,191,36,.45); background:rgba(251,191,36,.10)}
    .badge.bad{border-color: rgba(251,113,133,.45); background:rgba(251,113,133,.10)}
    .log{margin-top:10px; max-height: 260px; overflow:auto; padding-right:6px;}
    .log .line{font-size:12px; line-height:1.25; color:rgba(232,238,255,.85); padding:6px 0; border-bottom:1px dashed rgba(255,255,255,.10)}
    .log .line:last-child{border-bottom:none}
    .kbd{display:inline-block; padding:2px 6px; border-radius:6px; border:1px solid rgba(255,255,255,.18); background:rgba(255,255,255,.06); font-weight:900; font-size:11px;}
    .footer{margin-top:14px; font-size:12px; color:rgba(232,238,255,.7)}
    .battle{
      display:none;
      margin-top:10px;
      padding:12px;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.05);
    }
    .battle.active{display:block;}
    .battle .title{display:flex; justify-content:space-between; gap:8px; flex-wrap:wrap; align-items:center;}
    .battle .title b{color:#dbe4ff}
    .battle .cols{display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top:10px;}
    @media (max-width: 520px){ .battle .cols{grid-template-columns:1fr;} }
    .battle .box{padding:10px; border-radius:14px; border:1px solid rgba(255,255,255,.12); background:rgba(20,31,68,.55);}
    .hpbar{height:10px; border-radius:999px; background:rgba(255,255,255,.10); border:1px solid rgba(255,255,255,.10); overflow:hidden;}
    .hpbar > i{display:block; height:100%; width:50%; background: linear-gradient(90deg, rgba(52,211,153,.9), rgba(122,162,255,.9));}
    .skillrow{display:flex; gap:8px; flex-wrap:wrap; margin-top:10px;}
    .skillbtn{font-size:12px; padding:8px 10px; border-radius:12px; border:1px solid rgba(255,255,255,.16); background:rgba(255,255,255,.06); color:var(--text); cursor:pointer; font-weight:900;}
    .skillbtn:hover{border-color:rgba(122,162,255,.7); background:rgba(255,255,255,.10)}
    .skillbtn:disabled{opacity:.55; cursor:not-allowed;}
    .hint{font-size:12px; color:rgba(232,238,255,.78); margin-top:8px; line-height:1.25;}
    .party{display:grid; grid-template-columns:repeat(2,1fr); gap:8px; margin-top:10px;}
    .pchip{
      padding:10px; border-radius:14px; border:1px solid rgba(255,255,255,.12); background:rgba(255,255,255,.05);
      cursor:pointer;
    }
    .pchip.sel{border-color: rgba(52,211,153,.75); box-shadow: 0 0 0 2px rgba(52,211,153,.18) inset;}
    .pchip small{color:rgba(232,238,255,.70)}
    .evo{
      display:none; margin-top:10px; padding:10px; border-radius:14px;
      border:1px solid rgba(255,255,255,.12); background:rgba(52,211,153,.06);
    }
    .evo.active{display:block;}
    .evo .row{justify-content:flex-start}
  </style>
</head>
<body>
<div class="wrap">
  <div class="top">
    <div class="brand">
      <h1>64-Square Tactics</h1>
      <div class="tag">v3 • Territory ✅ • Battles (A) ✅ • Evolution framework ✅</div>
    </div>
    <div class="pillrow">
      <div class="pill">Build: <span id="pillBuild">—</span></div>
      <div class="pill">Turn: <span id="pillTurn">—</span></div>
      <div class="pill">Mode: <span id="pillMode">Draft</span></div>
      <div class="pill">Tiles: <span id="pillTiles">—</span></div>
    </div>
  </div>

  <!-- STAGE 1 -->
  <section class="panel stage active" id="stage-village">
    <div class="row">
      <div>
        <h2 style="margin:0;font-size:18px;">Choose your Village (¼)</h2>
        <p class="help">Village sets your primary color + macro doctrine. Unbalanced by design.</p>
      </div>
      <div class="row">
        <button class="btn" id="btnRandVillage">Random</button>
        <button class="btn primary" id="btnVillageNext" disabled>Next →</button>
      </div>
    </div>
    <div class="grid4" id="villageGrid"></div>
  </section>

  <!-- STAGE 2 -->
  <section class="panel stage" id="stage-clan">
    <div class="row">
      <div>
        <h2 style="margin:0;font-size:18px;">Choose your Clan (½)</h2>
        <p class="help">Clan tilts gradients/tones + economy/combat direction.</p>
      </div>
      <div class="row">
        <button class="btn" id="btnBackVillage">← Back</button>
        <button class="btn" id="btnRandClan">Random</button>
        <button class="btn primary" id="btnClanNext" disabled>Next →</button>
      </div>
    </div>
    <div class="grid4" id="clanGrid"></div>
  </section>

  <!-- STAGE 3 -->
  <section class="panel stage" id="stage-gene">
    <div class="row">
      <div>
        <h2 style="margin:0;font-size:18px;">Choose your Gene Affinity (¾)</h2>
        <p class="help">Your gene affinity empowers the matching soldier in your team of 4.</p>
      </div>
      <div class="row">
        <button class="btn" id="btnBackClan">← Back</button>
        <button class="btn" id="btnRandGene">Random</button>
        <button class="btn primary" id="btnToDeploy" disabled>Deploy →</button>
      </div>
    </div>
    <div class="grid4" id="geneGrid"></div>
  </section>

  <!-- BOARD -->
  <section class="panel stage" id="stage-board">
    <div class="row" style="margin-bottom:10px;">
      <div>
        <h2 style="margin:0;font-size:18px;">8×8 Territory Map</h2>
        <p class="help" id="boardHelp">
          <b>Deploy stage:</b> Click any tile to place your Base. Then enemies spawn. After that: <span class="kbd">WASD</span> move, <span class="kbd">1–4</span> select unit.
        </p>
      </div>
      <div class="row">
        <button class="btn" id="btnReset">New Build</button>
        <button class="btn danger" id="btnClearLog">Clear Log</button>
      </div>
    </div>

    <div class="arena">
      <canvas id="board" width="720" height="720"></canvas>

      <div class="hud">
        <h3>Commander HUD</h3>

        <div class="kv">
          <b>Village</b><span id="hudVillage">—</span>
          <b>Clan</b><span id="hudClan">—</span>
          <b>Gene</b><span id="hudGene">—</span>
          <b>Tech / Pop</b><span id="hudTP">—</span>
          <b>Resources</b><span id="hudRes">—</span>
          <b>Selected Unit</b><span id="hudUnit">—</span>
          <b>Win Condition</b><span id="hudWin">—</span>
        </div>

        <div class="mini" id="miniBadges"></div>

        <div class="divider"></div>

        <div class="party" id="partyBox"></div>

        <div class="evo" id="evoBox">
          <div style="font-weight:900; margin-bottom:6px;">Evolution Available</div>
          <div class="hint" id="evoHint">—</div>
          <div class="row" style="margin-top:10px;">
            <button class="btn primary" id="btnEvolveNow">Evolve Selected</button>
            <button class="btn" id="btnEvolveLater">Later</button>
          </div>
        </div>

        <div class="battle" id="battleBox">
          <div class="title">
            <div><b>Battle</b> • pick action (stamina)</div>
            <div><span class="kbd">Q</span> switch • <span class="kbd">R</span> rest • <span class="kbd">WASD</span> (disabled)</div>
          </div>

          <div class="cols">
            <div class="box">
              <div style="font-weight:900; margin-bottom:6px;" id="battlePName">—</div>
              <div class="hpbar"><i id="battlePHP"></i></div>
              <div class="hint" id="battlePStats">—</div>
              <div class="skillrow" id="battleSkills"></div>
              <div class="hint" id="battleStatusesP">—</div>
            </div>
            <div class="box">
              <div style="font-weight:900; margin-bottom:6px;" id="battleEName">—</div>
              <div class="hpbar"><i id="battleEHP"></i></div>
              <div class="hint" id="battleEStats">—</div>
              <div class="hint" id="battleStatusesE" style="margin-top:10px;">—</div>
            </div>
          </div>
        </div>

        <div class="log" id="log"></div>

        <div class="footer">
          <div><b>Battle keys:</b> <span class="kbd">Q</span> switch, <span class="kbd">R</span> rest. Moves appear as buttons.</div>
          <div><b>Stamina rule:</b> max 8; after you spend stamina, it fully regenerates after 5 turns.</div>
          <div><b>Evolution:</b> units gain XP, level up, and evolve at Lv 4 & Lv 8 (3-stage line).</div>
        </div>
      </div>
    </div>
  </section>

  <p class="footer">Next after this: (C) tech tree + map structures + more evolutions tied to tech.</p>
</div>

<script>
/* =========================================================
   DATA: Villages / Clans / Genes
   ========================================================= */

const VILLAGES = [
  { key:"SOL", name:"Solhaven", blurb:"Pop engine. Faster pop growth & healing, weaker burst.", color:"#7aa2ff",
    mods:{ pop:+2, heal:+2, atk:-1, def:+1 } },
  { key:"NOX", name:"Noxmoor", blurb:"Ambush doctrine. Higher crit/tempo, weaker sustain.", color:"#c084fc",
    mods:{ atk:+2, crit:+8, heal:-1, pop:0, def:-1 } },
  { key:"VER", name:"Verdant", blurb:"Resource advantage. More resources from tiles & camps.", color:"#34d399",
    mods:{ res:+2, tech:+1, atk:0, def:0 } },
  { key:"CIN", name:"Cinderhold", blurb:"War-first. Higher damage and capture pressure, weaker economy.", color:"#fb7185",
    mods:{ atk:+2, cap:+2, res:-1, pop:-1 } },
];

const CLANS = [
  { key:"FOR", name:"Forgeclan", blurb:"Tough kits. More defense; darker steel gradients.", tone:{a:0.18, b:0.55}, mods:{ def:+2, cap:+1 } },
  { key:"LOR", name:"Loreclan",  blurb:"Intel doctrine. Better tech from camps.", tone:{a:0.10, b:0.70}, mods:{ tech:+2, scan:+1, def:-1 } },
  { key:"RIV", name:"Rivenclan", blurb:"Mobility. Extra dodge chance.", tone:{a:0.14, b:0.62}, mods:{ spd:+1, dodge:+8, def:-1 } },
  { key:"RIT", name:"Riteclan",  blurb:"Momentum spikes. Stronger skills but +stamina tax.", tone:{a:0.22, b:0.68}, mods:{ atk:+1, burst:+1, staminaTax:+1 } },
];

const GENES = [
  { key:"KIN", name:"Kinetic", tag:"Tempo",
    blurb:"Tempo gene. Mobility & initiative.",
    mods:{ spd:+1, crit:+2 } },
  { key:"AEG", name:"Aegis", tag:"Defense",
    blurb:"Tank gene. Fortify, guard, and debuff resistance.",
    mods:{ def:+2 } },
  { key:"HEX", name:"Hexed", tag:"Variance",
    blurb:"Variance gene. Unstable power spikes.",
    mods:{ crit:+10 } },
  { key:"SYN", name:"Synergic", tag:"Cohesion",
    blurb:"Team gene. Healing & buffs.",
    mods:{ heal:+2 } },
];

/* =========================================================
   EVOLUTION FRAMEWORK
   - 3-stage lines by Gene
   - Evolves at Lv 4 and Lv 8
   - Each stage modifies stats and can unlock/upgrade moves
   ========================================================= */

const EVO = {
  evolveLevels: [4, 8],
  lines: {
    KIN: [
      { stage:1, form:"Runner",     mods:{ hp:+0, atk:+0, def:+0, crit:+0 }, unlock:[] },
      { stage:2, form:"Striker",    mods:{ hp:+6, atk:+2, def:+0, crit:+4 }, unlock:["kin_lunge"] },
      { stage:3, form:"Vanguard",   mods:{ hp:+10, atk:+4, def:+2, crit:+6 }, unlock:["kin_overrun"] },
    ],
    AEG: [
      { stage:1, form:"Shield",     mods:{ hp:+2, atk:+0, def:+1, crit:+0 }, unlock:[] },
      { stage:2, form:"Bulwark",    mods:{ hp:+10, atk:+1, def:+3, crit:+0 }, unlock:["aeg_break"] },
      { stage:3, form:"Citadel",    mods:{ hp:+16, atk:+2, def:+5, crit:+0 }, unlock:["aeg_fortress"] },
    ],
    HEX: [
      { stage:1, form:"Spark",      mods:{ hp:+0, atk:+1, def:+0, crit:+6 }, unlock:[] },
      { stage:2, form:"Hexcaster",  mods:{ hp:+6, atk:+3, def:+0, crit:+10 }, unlock:["hex_bolt"] },
      { stage:3, form:"Warlock",    mods:{ hp:+10, atk:+5, def:+1, crit:+14 }, unlock:["hex_cataclysm"] },
    ],
    SYN: [
      { stage:1, form:"Link",       mods:{ hp:+2, atk:+0, def:+0, crit:+0 }, unlock:[] },
      { stage:2, form:"Chanter",    mods:{ hp:+8, atk:+1, def:+1, crit:+0 }, unlock:["syn_rally"] },
      { stage:3, form:"Conductor",  mods:{ hp:+12, atk:+2, def:+2, crit:+0 }, unlock:["syn_hymn"] },
    ],
  }
};

/* =========================================================
   MOVES (pokemon-ish)
   - Basic attack always available
   - Each unit has a move list
   - Moves cost stamina; clan can add staminaTax
   ========================================================= */

const MOVES = {
  // universal
  basic: { key:"basic", name:"Strike", cost:0, kind:"damage", power:12, acc:0.92, desc:"Reliable damage." },
  focus: { key:"focus", name:"Focus", cost:2, kind:"buff", power:0, acc:1.00, desc:"+ATK (2 turns) and +crit." },

  // KIN
  kin_dash:     { key:"kin_dash", name:"Dash Strike", cost:2, kind:"damage", power:16, acc:0.90, desc:"Higher damage; +initiative next turn." , status:{ self:{ haste:1 } } },
  kin_lunge:    { key:"kin_lunge", name:"Lunge", cost:3, kind:"damage", power:20, acc:0.88, desc:"Heavy hit; chance to Bleed.", status:{ enemy:{ bleed:2 } }, statusChance:0.35 },
  kin_overrun:  { key:"kin_overrun", name:"Overrun", cost:4, kind:"damage", power:26, acc:0.82, desc:"Big hit; if crit, enemy Stunned 1.", status:{ enemy:{ stun:1 } }, statusChance:0.25 },

  // AEG
  aeg_guard:     { key:"aeg_guard", name:"Guard", cost:2, kind:"buff", power:0, acc:1.00, desc:"Gain Shield (absorbs dmg) and +DEF (2 turns).", status:{ self:{ shield:12, defUp:2 } } },
  aeg_break:     { key:"aeg_break", name:"Guard Breaker", cost:3, kind:"debuff", power:14, acc:0.90, desc:"Damage + enemy DEF↓ (2 turns).", status:{ enemy:{ defDown:2 } } },
  aeg_fortress:  { key:"aeg_fortress", name:"Fortress", cost:4, kind:"buff", power:0, acc:1.00, desc:"Big Shield + cleanse 1 debuff.", status:{ self:{ shield:20, cleanse:1 } } },

  // HEX
  hex_jolt:      { key:"hex_jolt", name:"Jolt", cost:2, kind:"variance", power:15, acc:0.88, desc:"Variance damage; small backlash chance.", backlash:0.10, backlashDmg:2 },
  hex_bolt:      { key:"hex_bolt", name:"Hex Bolt", cost:3, kind:"variance", power:22, acc:0.84, desc:"High variance; chance to Curse (atk↓).", status:{ enemy:{ atkDown:2 } }, statusChance:0.30, backlash:0.12, backlashDmg:3 },
  hex_cataclysm: { key:"hex_cataclysm", name:"Cataclysm", cost:5, kind:"variance", power:30, acc:0.78, desc:"Huge variance; self-chip guaranteed.", backlash:1.00, backlashDmg:6 },

  // SYN
  syn_patch:     { key:"syn_patch", name:"Patch Heal", cost:3, kind:"heal", power:16, acc:1.00, desc:"Heal self + a nearby ally (if any).", status:{} },
  syn_rally:     { key:"syn_rally", name:"Rally", cost:4, kind:"buff", power:0, acc:1.00, desc:"+ATK to team (2 turns) + small heal.", status:{ team:{ atkUp:2 }, self:{ heal:8 } } },
  syn_hymn:      { key:"syn_hymn", name:"Hymn", cost:5, kind:"heal", power:0, acc:1.00, desc:"Big heal + cleanse 1 status.", status:{ team:{ heal:14, cleanse:1 } } },
};

/* =========================================================
   UTIL
   ========================================================= */
const $ = (s)=>document.querySelector(s);
const $$ = (s)=>Array.from(document.querySelectorAll(s));
const clamp = (n,a,b)=>Math.max(a,Math.min(b,n));
const pick = (arr)=>arr[Math.floor(Math.random()*arr.length)];
function lerp(a,b,t){ return a+(b-a)*t; }

function setStage(id){
  $$(".stage").forEach(s=>s.classList.remove("active"));
  $(id).classList.add("active");
}
function hexToRgb(hex){
  const h = hex.replace("#","");
  const n = parseInt(h,16);
  return { r:(n>>16)&255, g:(n>>8)&255, b:n&255 };
}
function rgbToHex(r,g,b){
  const f = (x)=>x.toString(16).padStart(2,"0");
  return "#"+f(r)+f(g)+f(b);
}
function shade(hex, t){
  const c = hexToRgb(hex);
  const k = t>=0 ? 255 : 0;
  const a = Math.abs(t);
  return rgbToHex(
    Math.round(lerp(c.r, k, a)),
    Math.round(lerp(c.g, k, a)),
    Math.round(lerp(c.b, k, a))
  );
}
function gradColor(baseHex, toneA, toneB, u){
  const a = shade(baseHex, -toneA);
  const b = shade(baseHex, +toneB);
  const A = hexToRgb(a), B = hexToRgb(b);
  return rgbToHex(
    Math.round(lerp(A.r,B.r,u)),
    Math.round(lerp(A.g,B.g,u)),
    Math.round(lerp(A.b,B.b,u))
  );
}

/* =========================================================
   DRAFT UI
   ========================================================= */
const selection = { village:null, clan:null, gene:null };

function renderGrid(target, items, selectedKey, onPick){
  const el = $(target);
  el.innerHTML = "";
  items.forEach(it=>{
    const c = document.createElement("div");
    c.className = "card" + (selectedKey===it.key ? " sel":"");
    c.innerHTML = `<h3>${it.name} <span style="opacity:.7;font-size:12px;">(${it.key})</span></h3><p>${it.blurb}</p>`;
    c.addEventListener("click", ()=>onPick(it));
    el.appendChild(c);
  });
}
function updatePills(){
  const build = (selection.village && selection.clan && selection.gene)
    ? `${selection.village.key}-${selection.clan.key}-${selection.gene.key}` : "—";
  $("#pillBuild").textContent = build;
}
function pickVillage(v){
  selection.village=v; selection.clan=null; selection.gene=null;
  renderGrid("#villageGrid", VILLAGES, v.key, pickVillage);
  $("#btnVillageNext").disabled=false;
  updatePills();
}
function pickClan(c){
  selection.clan=c; selection.gene=null;
  renderGrid("#clanGrid", CLANS, c.key, pickClan);
  $("#btnClanNext").disabled=false;
  updatePills();
}
function pickGene(g){
  selection.gene=g;
  renderGrid("#geneGrid", GENES, g.key, pickGene);
  $("#btnToDeploy").disabled=false;
  updatePills();
}

renderGrid("#villageGrid", VILLAGES, null, pickVillage);

$("#btnRandVillage").addEventListener("click", ()=>pickVillage(pick(VILLAGES)));
$("#btnVillageNext").addEventListener("click", ()=>{
  renderGrid("#clanGrid", CLANS, null, pickClan);
  $("#btnClanNext").disabled=true;
  setStage("#stage-clan");
});
$("#btnBackVillage").addEventListener("click", ()=>setStage("#stage-village"));
$("#btnRandClan").addEventListener("click", ()=>pickClan(pick(CLANS)));
$("#btnClanNext").addEventListener("click", ()=>{
  renderGrid("#geneGrid", GENES, null, pickGene);
  $("#btnToDeploy").disabled=true;
  setStage("#stage-gene");
});
$("#btnBackClan").addEventListener("click", ()=>setStage("#stage-clan"));
$("#btnRandGene").addEventListener("click", ()=>pickGene(pick(GENES)));

$("#btnToDeploy").addEventListener("click", ()=>{
  initGameFromSelection();
  setStage("#stage-board");
});

/* =========================================================
   GAME RULES (Territory stays from v2)
   ========================================================= */
const canvas = $("#board");
const ctx = canvas.getContext("2d");

const SIZE = 8;
const PAD = 16;
let TILE = 0;

const RULES = {
  controlMax: 100,
  fortifyMax: 120,
  captureRate: 22,
  invadeRate: 18,
  neutralClaimRate: 26,
  frontlineDecay: 6,
  expansionChance: 0.12,
  baseFortHP: 90,
  dominationTiles: 40,

  // Battle
  turnShieldDecay: 1,          // shield decays per global turn
  dotBleedDmg: 3,              // bleed tick
  xpWin: 18,                   // XP per KO
  xpHit: 4,                    // XP per hit
  xpCamp: 10,                  // XP for camp integration
  xpRelic: 8,                  // XP for relic
};

const TILE_TYPES = [
  {key:"plain", name:"Plain", w:0.52},
  {key:"food",  name:"Food",  w:0.16},
  {key:"ore",   name:"Ore",   w:0.14},
  {key:"relic", name:"Relic", w:0.10},
  {key:"camp",  name:"Camp",  w:0.08},
];
function weightedTile(){
  const r = Math.random();
  let acc = 0;
  for(const t of TILE_TYPES){
    acc += t.w;
    if(r<=acc) return t.key;
  }
  return "plain";
}

const game = {
  phase:"deploy", // deploy | play | battle | over
  turn:0,
  board:[],
  villages:[],
  playerVillage:null,
  enemyVillages:[],
  resources:{ food:0, ore:0, relic:0 },
  tech:0,
  pop:0,
  units:[],
  selectedUnitId:null,
  battle:{
    active:false,
    // active on both sides
    pActiveId:null,
    eActiveId:null,
    // encounter context (for map effects)
    at:{x:0,y:0},
  },
};

function log(msg){
  const box = $("#log");
  const div = document.createElement("div");
  div.className="line";
  div.textContent=msg;
  box.prepend(div);
  while(box.children.length>80) box.removeChild(box.lastChild);
}

/* =========================================================
   Board helpers
   ========================================================= */
function idx(x,y){ return y*SIZE + x; }
function inside(x,y){ return x>=0 && y>=0 && x<SIZE && y<SIZE; }
function tileAt(x,y){ return game.board[idx(x,y)]; }
function neighbors4(x,y){
  return [{x:x+1,y},{x:x-1,y},{x,y:y+1},{x,y:y-1}].filter(p=>inside(p.x,p.y));
}
function dist(a,b){ return Math.abs(a.x-b.x)+Math.abs(a.y-b.y); }
function countTilesByVillage(){
  const out = {};
  for(const t of game.board){
    if(t.owner) out[t.owner] = (out[t.owner]||0)+1;
  }
  return out;
}
function villageAlive(key){
  const v = game.villages.find(v=>v.key===key);
  return v ? v.alive : false;
}

/* =========================================================
   Units / Stats / XP / Level / Evolution
   ========================================================= */
let _uid = 1;
function newId(){ return "u"+(_uid++); }

function xpForNext(level){
  // gentle curve
  return Math.floor(18 + level*10 + level*level*2);
}

function baseStatsForUnit(village, clan, gene){
  const base = { maxHp: 42, atk: 10, def: 8, crit: 5, dodge: 0 };
  const vmods = village.mods || {};
  const cmods = clan.mods || {};
  const gmods = gene.mods || {};

  base.maxHp = clamp(base.maxHp + (vmods.def||0)*2 + (gmods.def||0)*2, 30, 86);
  base.atk   = clamp(base.atk + (vmods.atk||0)*2 + (cmods.atk||0) + (gmods.atk||0), 6, 26);
  base.def   = clamp(base.def + (vmods.def||0)*2 + (cmods.def||0) + (gmods.def||0), 5, 26);
  base.crit  = clamp(base.crit + (vmods.crit||0) + (gmods.crit||0), 0, 50);
  base.dodge = clamp(base.dodge + (cmods.dodge||0), 0, 45);
  return base;
}

function geneLine(geneKey){
  return EVO.lines[geneKey] || [{stage:1,form:"Base",mods:{},unlock:[]}];
}

function currentEvoStage(unit){
  return unit.evoStage || 1;
}

function evoFormFor(unit){
  const line = geneLine(unit.geneKey);
  const s = clamp(currentEvoStage(unit), 1, line.length);
  return line[s-1];
}

function computeDerivedStats(unit){
  // Base stats are stored as "core" then modified by level and evolution
  const form = evoFormFor(unit);
  const lvl = unit.level;

  // level growth
  const growth = {
    hp: Math.floor((lvl-1) * 2.2),
    atk: Math.floor((lvl-1) * 0.9),
    def: Math.floor((lvl-1) * 0.8),
    crit: Math.floor((lvl-1) * 0.35),
  };

  const maxHp = clamp(unit.core.maxHp + growth.hp + (form.mods.hp||0), 28, 140);
  const atk   = clamp(unit.core.atk   + growth.atk + (form.mods.atk||0), 4, 40);
  const def   = clamp(unit.core.def   + growth.def + (form.mods.def||0), 2, 40);
  const crit  = clamp(unit.core.crit  + growth.crit + (form.mods.crit||0), 0, 60);

  // dodge stays mostly clan-driven but a tiny level bump
  const dodge = clamp(unit.core.dodge + Math.floor((lvl-1)*0.2), 0, 55);

  return { maxHp, atk, def, crit, dodge };
}

function defaultMovesForGene(geneKey){
  // Stage 1 always has a gene starter + Focus
  if(geneKey==="KIN") return ["basic","focus","kin_dash"];
  if(geneKey==="AEG") return ["basic","focus","aeg_guard"];
  if(geneKey==="HEX") return ["basic","focus","hex_jolt"];
  if(geneKey==="SYN") return ["basic","focus","syn_patch"];
  return ["basic","focus"];
}

function ensureMoveUnlocked(unit){
  // Apply evolution unlocks without duplicates
  const line = geneLine(unit.geneKey);
  const form = evoFormFor(unit);
  for(const mv of (form.unlock||[])){
    if(!unit.moves.includes(mv)) unit.moves.push(mv);
  }
}

function makeUnit({village, clan, gene, team, x, y, isPlayer}){
  const core = baseStatsForUnit(village, clan, gene);
  const id = newId();

  const unit = {
    id, isPlayer,
    villageKey: village.key,
    clanKey: clan.key,
    geneKey: gene.key,
    name: `${team}`,
    x,y,

    level: 1,
    xp: 0,
    nextXp: xpForNext(1),
    evoStage: 1,

    core,

    // derived set later
    maxHp: core.maxHp,
    atk: core.atk,
    def: core.def,
    crit: core.crit,
    dodge: core.dodge,

    hp: core.maxHp,

    sta: 8,
    lastStaSpendTurn: -999,

    // battle statuses (turn-based)
    status: {
      shield: 0,        // absorbs damage
      stun: 0,          // skip action
      bleed: 0,         // takes dot
      haste: 0,         // +initiative preference (AI uses; also minor acc)
      atkUp: 0,         // duration
      defUp: 0,
      atkDown: 0,
      defDown: 0,
      cleanse: 0,
    },

    moves: defaultMovesForGene(gene.key),
  };

  // player affinity boost
  if(isPlayer && gene.key===selection.gene.key){
    unit.level = 2;
    unit.nextXp = xpForNext(unit.level);
    unit.evoStage = 1;
    unit.xp = 0;
  }

  // derived stats
  const d = computeDerivedStats(unit);
  unit.maxHp = d.maxHp; unit.atk=d.atk; unit.def=d.def; unit.crit=d.crit; unit.dodge=d.dodge;
  unit.hp = unit.maxHp;

  return unit;
}

function grantXP(unit, amount){
  if(!unit || unit.hp<=0) return;
  unit.xp += amount;
  let leveled = false;

  while(unit.xp >= unit.nextXp){
    unit.xp -= unit.nextXp;
    unit.level++;
    unit.nextXp = xpForNext(unit.level);
    leveled = true;

    // recompute derived stats; keep hp ratio
    const beforeMax = unit.maxHp;
    const beforeFrac = beforeMax>0 ? (unit.hp/beforeMax) : 1;

    const d = computeDerivedStats(unit);
    unit.maxHp = d.maxHp; unit.atk=d.atk; unit.def=d.def; unit.crit=d.crit; unit.dodge=d.dodge;

    unit.hp = clamp(Math.ceil(unit.maxHp * beforeFrac) + 1, 1, unit.maxHp);

    log(`${unit.isPlayer?"Your":"Enemy"} unit ${unit.name} leveled up → Lv ${unit.level}.`);
  }

  if(unit.isPlayer && leveled){
    checkEvolutionPrompt();
    renderParty();
  }
}

function canEvolve(unit){
  if(!unit || unit.hp<=0) return false;
  const line = geneLine(unit.geneKey);
  if(unit.evoStage >= line.length) return false;

  const [l1,l2] = EVO.evolveLevels;
  if(unit.evoStage===1 && unit.level >= l1) return true;
  if(unit.evoStage===2 && unit.level >= l2) return true;
  return false;
}

function evolveUnit(unit){
  if(!canEvolve(unit)) return false;

  unit.evoStage++;
  const form = evoFormFor(unit);
  ensureMoveUnlocked(unit);

  // stats update
  const beforeMax = unit.maxHp;
  const beforeFrac = beforeMax>0 ? (unit.hp/beforeMax) : 1;

  const d = computeDerivedStats(unit);
  unit.maxHp = d.maxHp; unit.atk=d.atk; unit.def=d.def; unit.crit=d.crit; unit.dodge=d.dodge;
  unit.hp = clamp(Math.ceil(unit.maxHp * beforeFrac) + 4, 1, unit.maxHp);

  log(`EVOLUTION: ${unit.name} became ${unit.geneKey} ${form.form} (Stage ${unit.evoStage}).`);
  renderParty();
  updateHUD();
  draw();
  return true;
}

/* =========================================================
   Init game
   ========================================================= */
function initGameFromSelection(){
  const v = selection.village;
  const c = selection.clan;

  game.villages = [];
  game.enemyVillages = [];
  game.units = [];
  game.turn = 0;
  game.tech = 0;
  game.pop = 0;
  game.resources = {food:0, ore:0, relic:0};

  game.playerVillage = {
    key:v.key, name:v.name, color:v.color, tone: c.tone, mods:v.mods,
    isPlayer:true, alive:true, base:null
  };
  game.villages.push(game.playerVillage);

  game.board = [];
  for(let y=0;y<SIZE;y++){
    for(let x=0;x<SIZE;x++){
      game.board.push({
        type: weightedTile(),
        owner: null,
        control: 0,
        baseOf: null,
        fort: 0,
      });
    }
  }

  game.phase = "deploy";
  game.selectedUnitId = null;
  game.battle.active = false;
  $("#battleBox").classList.remove("active");
  $("#evoBox").classList.remove("active");

  $("#boardHelp").innerHTML = `<b>Deploy stage:</b> Click any tile to place your Base.`;
  log(`Build locked: ${selection.village.key}-${selection.clan.key}-${selection.gene.key} • Deploy your base.`);
  updateHUD();
  renderParty();
  draw();
}

$("#btnReset").addEventListener("click", ()=>hardReset());
$("#btnClearLog").addEventListener("click", ()=>$("#log").innerHTML="");

/* =========================================================
   Deploy / Spawn
   ========================================================= */
function findFarEmptySpot(from){
  let best = null;
  for(let i=0;i<160;i++){
    const x = Math.floor(Math.random()*SIZE);
    const y = Math.floor(Math.random()*SIZE);
    const t = tileAt(x,y);
    if(t.owner) continue;
    const d = from ? dist({x,y}, from) : 0;
    if(!best || d>best.d) best = {x,y,d};
  }
  return best ? {x:best.x,y:best.y} : {x:SIZE-1,y:SIZE-1};
}
function placeBase(village, x, y){
  const t = tileAt(x,y);
  t.owner = village.key;
  t.control = RULES.controlMax;
  t.baseOf = village.key;
  t.fort = RULES.baseFortHP;
  village.base = {x,y, fort: t.fort};
}

function spawnEnemiesAfterDeploy(){
  const enemyCount = 1 + Math.floor(Math.random()*3);
  const available = VILLAGES.filter(x=>x.key!==game.playerVillage.key);
  const pBase = game.playerVillage.base;

  for(let i=0;i<enemyCount;i++){
    const baseV = available.splice(Math.floor(Math.random()*available.length),1)[0] || pick(VILLAGES);
    const clan = pick(CLANS);
    const enemy = {
      key: baseV.key, name: baseV.name, color: baseV.color, tone: clan.tone, mods: baseV.mods,
      isPlayer:false, alive:true, base:null
    };
    game.enemyVillages.push(enemy);
    game.villages.push(enemy);

    const pos = findFarEmptySpot(pBase);
    placeBase(enemy, pos.x, pos.y);

    // enemy team of 2 (for now) but battles are 1v1 active with switching
    const genes = [pick(GENES), pick(GENES), pick(GENES), pick(GENES)];
    for(let k=0;k<2;k++){
      const u = makeUnit({village: enemy, clan, gene:genes[k], team:`${enemy.key}-${k+1}`, x:pos.x, y:pos.y, isPlayer:false});
      // make enemies slightly stronger on average
      u.level = 2 + Math.floor(Math.random()*2);
      u.nextXp = xpForNext(u.level);
      const d = computeDerivedStats(u);
      u.maxHp = d.maxHp; u.atk=d.atk; u.def=d.def; u.crit=d.crit; u.dodge=d.dodge;
      u.hp = u.maxHp;
      game.units.push(u);
    }
  }

  // Player team of 4 around base: each gene once
  const pb = game.playerVillage.base;
  const playerClan = selection.clan;
  const genes = [...GENES];
  genes.sort((a,b)=> (a.key===selection.gene.key? -1:0) + (b.key===selection.gene.key? 1:0));
  const spots = [ {x:pb.x,y:pb.y}, ...neighbors4(pb.x,pb.y) ];

  for(let i=0;i<4;i++){
    const s = spots[i] || pb;
    const gene = genes[i];
    const u = makeUnit({village: game.playerVillage, clan: playerClan, gene, team:`P${i+1}`, x:s.x, y:s.y, isPlayer:true});
    game.units.push(u);
  }

  const first = game.units.find(u=>u.isPlayer);
  game.selectedUnitId = first?.id ?? null;

  game.phase = "play";
  game.turn = 1;
  $("#boardHelp").innerHTML =
    `Turn-based play: <span class="kbd">WASD</span> move (ends turn), <span class="kbd">1–4</span> select unit. Battles trigger when adjacent to an enemy.`;
  log(`Enemy villages spawned: ${game.enemyVillages.map(v=>v.key).join(", ")}. Your turn begins.`);
  updateHUD();
  renderParty();
  draw();
}

/* =========================================================
   Input
   ========================================================= */
function isOccupied(x,y){
  return game.units.some(u=>u.hp>0 && u.x===x && u.y===y && (u.isPlayer || villageAlive(u.villageKey)));
}
function enemyAdjacentTo(u){
  const enemies = game.units.filter(e=>!e.isPlayer && e.hp>0 && villageAlive(e.villageKey));
  for(const e of enemies){
    if(dist(u,e)===1) return e;
  }
  return null;
}

window.addEventListener("keydown", (e)=>{
  const k = e.key;

  // Party selection keys
  if(["1","2","3","4"].includes(k) && (game.phase==="play")){
    const units = game.units.filter(u=>u.isPlayer);
    const i = parseInt(k,10)-1;
    const u = units[i];
    if(u && u.hp>0){
      game.selectedUnitId = u.id;
      log(`Selected ${u.name}.`);
      updateHUD(); renderParty(); draw();
      checkEvolutionPrompt();
    }
    return;
  }

  // Battle hotkeys
  if(game.phase==="battle"){
    if(k==="q" || k==="Q"){ battleOpenSwitch(); return; }
    if(k==="r" || k==="R"){ battleDoRest(); return; }
    return;
  }

  if(game.phase!=="play") return;

  const map = { w:[0,-1], a:[-1,0], s:[0,1], d:[1,0], W:[0,-1], A:[-1,0], S:[0,1], D:[1,0] };
  if(map[k]){
    e.preventDefault();
    const [dx,dy] = map[k];
    playerMove(dx,dy);
  }
}, {passive:false});

canvas.addEventListener("click", (e)=>{
  if(game.phase!=="deploy") return;
  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX-rect.left) * (canvas.width/rect.width);
  const my = (e.clientY-rect.top) * (canvas.height/rect.height);
  const {x,y} = pixelToCell(mx,my);
  if(!inside(x,y)) return;
  if(tileAt(x,y).owner) return;

  placeBase(game.playerVillage, x, y);
  log(`Base deployed: ${game.playerVillage.key} at (${x+1},${y+1}).`);
  spawnEnemiesAfterDeploy();
});

/* =========================================================
   Territory pressure + economy (same design, with XP gains)
   ========================================================= */
function applyTerritoryStand(unit){
  const t = tileAt(unit.x, unit.y);
  const capBonus = unit.isPlayer ? (game.playerVillage.mods.cap||0) : 0;

  if(t.baseOf && t.baseOf !== unit.villageKey){
    const dmg = RULES.invadeRate + capBonus;
    t.fort = clamp(t.fort - dmg, 0, RULES.baseFortHP);
    log(`${unit.name} pressures ENEMY BASE (${t.baseOf}) → Fort -${dmg} (now ${Math.ceil(t.fort)}).`);
    if(t.fort<=0){
      eliminateVillage(t.baseOf);
      t.owner = unit.villageKey;
      t.control = RULES.controlMax;
      t.baseOf = unit.villageKey;
      t.fort = RULES.baseFortHP;
      const v = game.villages.find(v=>v.key===unit.villageKey);
      if(v) v.base = {x:unit.x,y:unit.y, fort:t.fort};
      log(`BASE CAPTURED → ${unit.villageKey} now holds the base.`);
      if(unit.isPlayer) grantXP(unit, 12);
    }
    return;
  }

  if(!t.owner){
    t.owner = unit.villageKey;
    t.control = clamp(t.control + (RULES.neutralClaimRate + capBonus), 0, RULES.controlMax);
    if(unit.isPlayer) log(`${unit.name} claims neutral territory → Control ${Math.ceil(t.control)}.`);
    return;
  }

  if(t.owner === unit.villageKey){
    const gain = RULES.captureRate + capBonus;
    t.control = clamp(t.control + gain, 0, (t.baseOf?RULES.fortifyMax:RULES.controlMax));
    return;
  }

  const loss = RULES.invadeRate + capBonus;
  t.control = clamp(t.control - loss, 0, RULES.controlMax);
  if(unit.isPlayer) log(`${unit.name} invades ${t.owner} tile → Control -${loss} (now ${Math.ceil(t.control)}).`);
  if(t.control<=0){
    t.owner = unit.villageKey;
    t.control = clamp(20 + capBonus*5, 0, RULES.controlMax);
    if(unit.isPlayer) log(`TILE CAPTURED by ${unit.villageKey} → Control ${Math.ceil(t.control)}.`);
    if(unit.isPlayer) grantXP(unit, 5);
  }
}

function resolveTileEconomy(unit){
  const t = tileAt(unit.x, unit.y);
  if(t.owner !== unit.villageKey) return;
  if(t.control < 40 && !t.baseOf) return;

  const vm = unit.isPlayer ? (game.playerVillage.mods||{}) : {};
  const resBonus = vm.res||0;
  const popBonus = vm.pop||0;
  const techBonus= vm.tech||0;

  if(t.type==="food"){
    game.resources.food += 1 + Math.max(0,popBonus);
    game.pop += 1 + Math.max(0,popBonus);
    if(unit.isPlayer) { log(`${unit.name} harvested Food → +food, +pop.`); grantXP(unit, 3); }
    t.type="plain";
  } else if(t.type==="ore"){
    game.resources.ore += 1 + Math.max(0,resBonus);
    if(unit.isPlayer) { log(`${unit.name} mined Ore → +ore.`); grantXP(unit, 3); }
    t.type="plain";
  } else if(t.type==="relic"){
    game.resources.relic += 1 + Math.max(0,techBonus);
    game.tech += 1 + Math.max(0,techBonus);
    if(unit.isPlayer) { log(`${unit.name} recovered Relic → +relic, +tech.`); grantXP(unit, RULES.xpRelic); }
    t.type="plain";
  } else if(t.type==="camp"){
    const r = Math.random();
    if(r<0.50){
      game.tech += 2 + (vm.tech||0);
      if(unit.isPlayer) log(`${unit.name} secured a Camp → +tech.`);
    } else {
      game.pop += 2 + (vm.pop||0);
      if(unit.isPlayer) log(`${unit.name} integrated a Camp → +pop.`);
    }
    if(unit.isPlayer) grantXP(unit, RULES.xpCamp);
    t.type="plain";
  }
}

/* =========================================================
   Movement
   ========================================================= */
function playerMove(dx,dy){
  const u = game.units.find(x=>x.id===game.selectedUnitId);
  if(!u || !u.isPlayer || u.hp<=0) return;

  const nx = u.x + dx, ny = u.y + dy;
  if(!inside(nx,ny)) return;
  if(isOccupied(nx,ny)) return;

  u.x=nx; u.y=ny;

  applyTerritoryStand(u);
  resolveTileEconomy(u);

  const adjEnemy = enemyAdjacentTo(u);
  if(adjEnemy){
    startBattleEncounter(u, adjEnemy);
    updateHUD(); renderParty(); draw();
    return;
  }

  advanceTurn(); // ONLY progresses after player move
}

/* =========================================================
   Turn progression (global)
   ========================================================= */
function tickStatusesGlobal(){
  for(const u of game.units){
    if(u.hp<=0) continue;
    // shield decays slightly per turn
    if(u.status.shield>0) u.status.shield = Math.max(0, u.status.shield - RULES.turnShieldDecay);

    // duration statuses
    const durKeys = ["stun","bleed","haste","atkUp","defUp","atkDown","defDown"];
    for(const k of durKeys){
      if(u.status[k]>0) u.status[k]--;
    }

    // DOT
    if(u.status.bleed>0){
      const dmg = RULES.dotBleedDmg;
      applyDamage(u, dmg, {trueDmg:true});
      if(u.isPlayer) log(`${u.name} bleeds for ${dmg}.`);
    }
  }
}

function staminaRegenRule(){
  for(const u of game.units){
    if(u.sta < 8 && (game.turn - u.lastStaSpendTurn) >= 5){
      u.sta = 8;
      if(u.isPlayer) log(`${u.name} stamina fully regenerated (5-turn rule).`);
    }
  }
}

function territoryUpkeep(){
  for(let y=0;y<SIZE;y++){
    for(let x=0;x<SIZE;x++){
      const t = tileAt(x,y);
      if(!t.owner) continue;

      const nearEnemy = neighbors4(x,y).some(p=>{
        const nt = tileAt(p.x,p.y);
        return nt.owner && nt.owner !== t.owner;
      });

      if(nearEnemy && t.control < 60 && !t.baseOf){
        t.control = clamp(t.control - RULES.frontlineDecay, 0, RULES.controlMax);
        if(t.control<=0){
          t.owner = null;
          t.control = 0;
        }
      } else {
        const cap = t.baseOf ? RULES.fortifyMax : RULES.controlMax;
        t.control = clamp(t.control + 4, 0, cap);
      }
    }
  }

  for(const v of game.villages.filter(v=>v.alive)){
    if(Math.random() > RULES.expansionChance) continue;

    const candidates = [];
    for(let y=0;y<SIZE;y++){
      for(let x=0;x<SIZE;x++){
        const t = tileAt(x,y);
        if(t.owner !== v.key) continue;
        for(const n of neighbors4(x,y)){
          const nt = tileAt(n.x,n.y);
          if(!nt.owner) candidates.push({x:n.x,y:n.y});
        }
      }
    }
    if(candidates.length===0) continue;
    const c = candidates[Math.floor(Math.random()*candidates.length)];
    const nt = tileAt(c.x,c.y);
    nt.owner = v.key;
    nt.control = 18;
    log(`Expansion: ${v.key} claims new territory at (${c.x+1},${c.y+1}).`);
  }
}

function enemyActMap(){
  // lighter map AI: they drift toward nearest player unit and apply territory stand; battles start only from player adjacency
  const enemies = game.units.filter(u=>!u.isPlayer && u.hp>0 && villageAlive(u.villageKey));
  const players = game.units.filter(u=>u.isPlayer && u.hp>0);
  if(players.length===0) return;

  for(const e of enemies){
    const target = nearestPlayerUnit(e);
    if(!target) continue;

    // if adjacent, they don't auto-start a battle (player must choose engagements); but they can apply pressure by moving
    const step = stepToward(e, target);
    if(step){
      e.x = step.x; e.y = step.y;
      applyTerritoryStand(e);
    }
  }
}

function nearestPlayerUnit(from){
  const players = game.units.filter(u=>u.isPlayer && u.hp>0);
  let best = null;
  for(const p of players){
    const d = dist(from,p);
    if(!best || d<best.d) best = {u:p,d};
  }
  return best?.u ?? null;
}
function stepToward(unit, target){
  const opts = neighbors4(unit.x, unit.y);
  const occupied = new Set(game.units.filter(u=>u.hp>0).map(u=>u.x+","+u.y));
  const candidates = opts.filter(p=>!occupied.has(p.x+","+p.y));
  if(candidates.length===0) return null;
  candidates.sort((a,b)=>dist(a,target)-dist(b,target));
  return candidates[0];
}

function advanceTurn(){
  if(game.phase!=="play") return;

  tickStatusesGlobal();
  staminaRegenRule();
  territoryUpkeep();
  enemyActMap();
  checkEnd();

  game.turn++;
  updateHUD();
  renderParty();
  draw();
  checkEvolutionPrompt();
}

/* =========================================================
   Village elimination
   ========================================================= */
function eliminateVillage(vKey){
  const v = game.villages.find(v=>v.key===vKey);
  if(!v || !v.alive) return;
  v.alive = false;

  for(const u of game.units){
    if(u.villageKey===vKey) u.hp = 0;
  }

  for(const t of game.board){
    if(t.owner===vKey){
      t.control = Math.max(0, t.control-55);
      if(t.control<=0){
        t.owner = null;
        t.control = 0;
      }
      if(t.baseOf===vKey){
        t.baseOf = null;
        t.fort = 0;
      }
    }
  }

  log(`Village eliminated: ${vKey}. Their units collapse and territory crumbles.`);
}

/* =========================================================
   Battle System (A) — deeper, pokemon-ish
   - Encounter begins when player moves adjacent to enemy
   - Each side has a party: Player = 4 units; Enemy = 2 units (for now)
   - Active unit fights; switching costs the turn
   - Status effects: shield, stun, bleed, atkUp/Down, defUp/Down, haste
   ========================================================= */

function unitsBySide(isPlayer){
  return game.units.filter(u=>u.isPlayer===isPlayer && u.hp>0 && (isPlayer || villageAlive(u.villageKey)));
}

function startBattleEncounter(playerUnit, enemyUnit){
  game.phase="battle";
  game.battle.active = true;
  game.battle.at = {x: playerUnit.x, y: playerUnit.y};

  // active unit is selected player; enemy active is the adjacent unit
  game.battle.pActiveId = playerUnit.id;
  game.battle.eActiveId = enemyUnit.id;

  log(`Battle engaged at (${playerUnit.x+1},${playerUnit.y+1}): ${playerUnit.name} vs ${enemyUnit.villageKey}:${enemyUnit.name}`);

  $("#battleBox").classList.add("active");
  $("#evoBox").classList.remove("active");

  renderBattleUI();
}

function endBattleToMap(victory){
  game.phase="play";
  game.battle.active=false;
  $("#battleBox").classList.remove("active");

  if(victory){
    // Victory momentum: apply extra territory pressure on the battle tile
    const p = game.units.find(u=>u.id===game.battle.pActiveId);
    if(p && p.hp>0){
      applyTerritoryStand(p);
      applyTerritoryStand(p);
      log("Momentum → extra territory pressure applied.");
    }
  }

  game.battle.pActiveId=null;
  game.battle.eActiveId=null;

  advanceTurn(); // battle action consumed the player's turn already; this advances global turn once at battle end
}

function applyDamage(target, dmg, {trueDmg=false}={}){
  if(target.hp<=0) return 0;
  let remaining = dmg;

  if(!trueDmg && target.status.shield>0){
    const s = Math.min(target.status.shield, remaining);
    target.status.shield -= s;
    remaining -= s;
  }

  target.hp -= remaining;
  if(target.hp<=0) target.hp=0;
  return remaining;
}

function effAtk(unit){
  let atk = unit.atk;
  if(unit.status.atkUp>0) atk += 2;
  if(unit.status.atkDown>0) atk -= 2;
  return Math.max(1, atk);
}
function effDef(unit){
  let def = unit.def;
  if(unit.status.defUp>0) def += 2;
  if(unit.status.defDown>0) def -= 2;
  return Math.max(1, def);
}

function hitRoll(acc, attacker){
  const hasteBonus = attacker.status.haste>0 ? 0.03 : 0;
  return Math.random() < clamp(acc + hasteBonus, 0.55, 0.98);
}

function critRoll(attacker){
  const c = clamp(attacker.crit,0,60)/100;
  return Math.random() < c;
}
function dodgeRoll(defender){
  const d = clamp(defender.dodge,0,55)/100;
  return Math.random() < d;
}

function calcDamage(attacker, defender, move){
  // pokemon-ish: power + atk - def scaling + variance; crit & dodge
  const a = effAtk(attacker);
  const d = effDef(defender);

  let base = (move.power || 0);
  if(move.kind==="buff" || move.kind==="heal") base = 0;

  let raw = 6 + (base * 0.72) + (a * 0.65) - (d * 0.45);
  raw = clamp(raw, 3, 34);

  // variance moves
  if(move.kind==="variance"){
    raw *= (0.75 + Math.random()*0.75);
  } else {
    raw *= (0.92 + Math.random()*0.20);
  }

  // defender AEG passive: -15% dmg (gene identity)
  if(defender.geneKey==="AEG") raw *= 0.85;

  const crit = critRoll(attacker);
  if(crit) raw *= 1.35;

  const dodged = dodgeRoll(defender);
  if(dodged) raw *= 0.35;

  return { dmg: Math.max(1, Math.round(raw)), crit, dodged };
}

function applyMoveStatuses(attacker, defender, move){
  // cleanse handling
  function cleanseOne(u){
    // remove one of these if present
    const order = ["stun","bleed","atkDown","defDown"];
    for(const k of order){
      if(u.status[k]>0){ u.status[k]=0; return k; }
    }
    return null;
  }

  // self buffs
  if(move.status?.self){
    for(const [k,v] of Object.entries(move.status.self)){
      if(k==="shield") attacker.status.shield += v;
      else if(k==="heal") attacker.hp = clamp(attacker.hp + v, 0, attacker.maxHp);
      else if(k==="cleanse"){
        const removed = cleanseOne(attacker);
        if(removed) log(`${attacker.name} cleansed ${removed}.`);
      } else {
        attacker.status[k] = Math.max(attacker.status[k], v);
      }
    }
  }

  // team buffs (player team only for now)
  if(move.status?.team){
    const team = unitsBySide(attacker.isPlayer);
    for(const ally of team){
      if(move.status.team.heal){
        ally.hp = clamp(ally.hp + move.status.team.heal, 0, ally.maxHp);
      }
      if(move.status.team.atkUp){
        ally.status.atkUp = Math.max(ally.status.atkUp, move.status.team.atkUp);
      }
      if(move.status.team.cleanse){
        const removed = (function(){
          const order = ["stun","bleed","atkDown","defDown"];
          for(const k of order){
            if(ally.status[k]>0){ ally.status[k]=0; return k; }
          }
          return null;
        })();
        if(removed && ally.isPlayer) log(`${ally.name} cleansed ${removed}.`);
      }
    }
  }

  // enemy debuffs
  if(move.status?.enemy){
    const chance = move.statusChance ?? 1.0;
    if(Math.random() <= chance){
      for(const [k,v] of Object.entries(move.status.enemy)){
        defender.status[k] = Math.max(defender.status[k], v);
      }
    }
  }
}

function consumeStamina(attacker, cost){
  attacker.sta = clamp(attacker.sta - cost, 0, 8);
  if(cost>0) attacker.lastStaSpendTurn = game.turn;
}

function moveCostWithClan(move, attacker){
  const clan = (attacker.isPlayer ? selection.clan : CLANS.find(c=>c.key===attacker.clanKey)) || {mods:{}};
  const tax = clan?.mods?.staminaTax || 0;
  return move.cost + tax;
}

function renderBattleUI(){
  const p = game.units.find(u=>u.id===game.battle.pActiveId);
  const e = game.units.find(u=>u.id===game.battle.eActiveId);
  if(!p || !e || p.hp<=0 || e.hp<=0){
    // auto-resolve if someone is down
    if(p && p.hp<=0){
      // try auto-switch player if possible
      const alive = unitsBySide(true).filter(u=>u.id!==p.id);
      if(alive.length>0){
        game.battle.pActiveId = alive[0].id;
        return renderBattleUI();
      }
      log("Battle lost: all units down.");
      endBattleToMap(false);
      return;
    }
    if(e && e.hp<=0){
      // enemy auto-switch if possible, else victory
      const aliveE = unitsBySide(false).filter(u=>u.id!==e.id);
      if(aliveE.length>0){
        game.battle.eActiveId = aliveE[0].id;
        log(`Enemy switched in ${aliveE[0].name}.`);
        return renderBattleUI();
      }
      log("Battle won: enemy party cleared.");
      endBattleToMap(true);
      return;
    }
  }

  // statuses tick at start of battle action? We'll show current only; global tick happens with turns.
  $("#battlePName").textContent = `You: ${p.name} • Lv ${p.level} • ${p.geneKey} ${evoFormFor(p).form}`;
  $("#battleEName").textContent = `Enemy: ${e.villageKey}:${e.name} • Lv ${e.level} • ${e.geneKey} ${evoFormFor(e).form}`;
  $("#battlePHP").style.width = `${clamp((p.hp/p.maxHp)*100,0,100).toFixed(0)}%`;
  $("#battleEHP").style.width = `${clamp((e.hp/e.maxHp)*100,0,100).toFixed(0)}%`;

  $("#battlePStats").textContent = `HP ${Math.ceil(p.hp)}/${p.maxHp} • STA ${p.sta}/8 • ATK ${effAtk(p)} • DEF ${effDef(p)} • Crit ${p.crit}%`;
  $("#battleEStats").textContent = `HP ${Math.ceil(e.hp)}/${e.maxHp} • ATK ${effAtk(e)} • DEF ${effDef(e)} • Crit ${e.crit}%`;

  $("#battleStatusesP").textContent = `Status: ${statusText(p)}`;
  $("#battleStatusesE").textContent = `Status: ${statusText(e)}`;

  // build move buttons from p.moves (first 4 max)
  const skills = $("#battleSkills");
  skills.innerHTML = "";

  // if stunned, only show "Skip"
  if(p.status.stun>0){
    const b = document.createElement("button");
    b.className="skillbtn";
    b.textContent = `Stunned (Skip)`;
    b.addEventListener("click", ()=>battleSkipTurn());
    skills.appendChild(b);
    return;
  }

  for(const mvKey of p.moves.slice(0,4)){
    const mv = MOVES[mvKey];
    if(!mv) continue;
    const cost = moveCostWithClan(mv, p);
    const btn = document.createElement("button");
    btn.className="skillbtn";
    btn.textContent = `${mv.name} (-${cost})`;
    btn.title = mv.desc;
    btn.disabled = (p.sta < cost);
    btn.addEventListener("click", ()=>battlePlayerUseMove(mvKey));
    skills.appendChild(btn);
  }

  // Switch / Rest
  const btnSwitch = document.createElement("button");
  btnSwitch.className="skillbtn";
  btnSwitch.textContent = `Switch (Q)`;
  btnSwitch.addEventListener("click", ()=>battleOpenSwitch());
  skills.appendChild(btnSwitch);

  const btnRest = document.createElement("button");
  btnRest.className="skillbtn";
  btnRest.textContent = `Rest (+2 STA)`;
  btnRest.addEventListener("click", ()=>battleDoRest());
  skills.appendChild(btnRest);
}

function statusText(u){
  const parts = [];
  if(u.status.shield>0) parts.push(`Shield ${u.status.shield}`);
  if(u.status.stun>0) parts.push(`Stun ${u.status.stun}`);
  if(u.status.bleed>0) parts.push(`Bleed ${u.status.bleed}`);
  if(u.status.haste>0) parts.push(`Haste ${u.status.haste}`);
  if(u.status.atkUp>0) parts.push(`ATK↑ ${u.status.atkUp}`);
  if(u.status.defUp>0) parts.push(`DEF↑ ${u.status.defUp}`);
  if(u.status.atkDown>0) parts.push(`ATK↓ ${u.status.atkDown}`);
  if(u.status.defDown>0) parts.push(`DEF↓ ${u.status.defDown}`);
  return parts.length ? parts.join(" • ") : "None";
}

function battleSkipTurn(){
  const p = game.units.find(u=>u.id===game.battle.pActiveId);
  if(!p) return;
  log(`${p.name} is stunned and loses the action.`);
  battleEnemyRespond();
  battleAfterExchange();
}

function battlePlayerUseMove(mvKey){
  const p = game.units.find(u=>u.id===game.battle.pActiveId);
  const e = game.units.find(u=>u.id===game.battle.eActiveId);
  if(!p || !e) return;
  const mv = MOVES[mvKey];
  if(!mv) return;

  const cost = moveCostWithClan(mv, p);
  if(p.sta < cost) return;

  consumeStamina(p, cost);

  // accuracy
  if(!hitRoll(mv.acc ?? 1.0, p)){
    log(`${p.name} used ${mv.name} → missed.`);
    battleEnemyRespond();
    battleAfterExchange();
    return;
  }

  // do effect
  if(mv.kind==="damage" || mv.kind==="variance"){
    const {dmg, crit, dodged} = calcDamage(p, e, mv);
    const dealt = applyDamage(e, dmg);
    log(`${p.name} used ${mv.name} → ${dealt} dmg${crit?" (CRIT)":" "}${dodged?" (Dodged)":" "}.`);
    grantXP(p, RULES.xpHit);

    // backlash
    if(mv.backlash && Math.random() < mv.backlash){
      const b = mv.backlashDmg || 2;
      applyDamage(p, b, {trueDmg:true});
      log(`Backlash → ${p.name} takes ${b}.`);
    }
  }
  else if(mv.kind==="buff"){
    log(`${p.name} used ${mv.name}.`);
  }
  else if(mv.kind==="heal"){
    // heal handled by statuses
    log(`${p.name} used ${mv.name}.`);
  }
  else if(mv.kind==="debuff"){
    const {dmg} = calcDamage(p, e, mv);
    const dealt = applyDamage(e, dmg);
    log(`${p.name} used ${mv.name} → ${dealt} dmg + debuff.`);
    grantXP(p, RULES.xpHit);
  }

  applyMoveStatuses(p, e, mv);

  // KO check
  if(e.hp<=0){
    log(`Enemy ${e.villageKey}:${e.name} was defeated.`);
    grantXP(p, RULES.xpWin);
    renderBattleUI(); // this will auto-switch or end
    return;
  }

  battleEnemyRespond();
  battleAfterExchange();
}

function battleOpenSwitch(){
  const p = game.units.find(u=>u.id===game.battle.pActiveId);
  if(!p) return;

  // Switching costs the player's action (enemy still responds)
  const alive = unitsBySide(true);
  if(alive.length<=1){
    log("No other units to switch to.");
    return;
  }

  // choose next alive unit (simple cycling)
  const idx = alive.findIndex(u=>u.id===p.id);
  const next = alive[(idx+1) % alive.length];
  game.battle.pActiveId = next.id;
  game.selectedUnitId = next.id;

  log(`Switch → ${next.name} enters.`);

  // enemy responds to switch (like pokemon)
  battleEnemyRespond();
  battleAfterExchange();
}

function battleDoRest(){
  const p = game.units.find(u=>u.id===game.battle.pActiveId);
  if(!p) return;
  p.sta = clamp(p.sta + 2, 0, 8);
  log(`${p.name} rests → +2 STA.`);
  battleEnemyRespond();
  battleAfterExchange();
}

function battleEnemyRespond(){
  const p = game.units.find(u=>u.id===game.battle.pActiveId);
  let e = game.units.find(u=>u.id===game.battle.eActiveId);
  if(!p || !e) return;

  // if enemy stunned, they skip
  if(e.status.stun>0){
    log(`Enemy ${e.name} is stunned and skips.`);
    return;
  }

  // enemy AI: pick a move it can afford; favor damage if player low
  const moveKeys = e.moves.slice(0,4).filter(k=>MOVES[k]);
  // ensure unlocks applied if evolved
  ensureMoveUnlocked(e);

  let best = null;
  for(const k of moveKeys){
    const mv = MOVES[k];
    const cost = moveCostWithClan(mv, e);
    if(e.sta < cost) continue;
    const score =
      (mv.kind==="damage"||mv.kind==="variance") ? (mv.power||0) :
      (mv.kind==="debuff") ? 16 :
      (mv.kind==="buff") ? 10 :
      (mv.kind==="heal") ? (e.hp < e.maxHp*0.55 ? 18 : 6) : 8;
    const urgency = (p.hp < p.maxHp*0.35) ? 6 : 0;
    const s = score + (mv.kind!=="heal"?urgency:0) + (Math.random()*3);
    if(!best || s>best.s) best = {k, mv, cost, s};
  }

  // if nothing affordable: rest
  if(!best){
    e.sta = clamp(e.sta + 2, 0, 8);
    log(`Enemy ${e.name} rests → +2 STA.`);
    return;
  }

  const mv = best.mv;
  consumeStamina(e, best.cost);

  if(!hitRoll(mv.acc ?? 1.0, e)){
    log(`Enemy ${e.name} used ${mv.name} → missed.`);
    return;
  }

  if(mv.kind==="damage" || mv.kind==="variance"){
    const {dmg, crit, dodged} = calcDamage(e, p, mv);
    const dealt = applyDamage(p, dmg);
    log(`Enemy ${e.name} used ${mv.name} → ${dealt} dmg${crit?" (CRIT)":" "}${dodged?" (Dodged)":" "}.`);
    if(mv.backlash && Math.random() < mv.backlash){
      const b = mv.backlashDmg || 2;
      applyDamage(e, b, {trueDmg:true});
      log(`Enemy backlash → ${e.name} takes ${b}.`);
    }
  } else if(mv.kind==="debuff"){
    const {dmg} = calcDamage(e, p, mv);
    const dealt = applyDamage(p, dmg);
    log(`Enemy ${e.name} used ${mv.name} → ${dealt} dmg + debuff.`);
  } else if(mv.kind==="heal" || mv.kind==="buff"){
    log(`Enemy ${e.name} used ${mv.name}.`);
  }

  applyMoveStatuses(e, p, mv);

  // if player downed, auto-switch (battle continues) or lose
  if(p.hp<=0){
    log(`${p.name} was downed.`);
  }
}

function battleAfterExchange(){
  // Update UI; if someone died, renderBattleUI will resolve end/switch on next call
  renderBattleUI();

  const p = game.units.find(u=>u.id===game.battle.pActiveId);
  const e = game.units.find(u=>u.id===game.battle.eActiveId);

  // if player party wiped -> defeat
  if(unitsBySide(true).length===0){
    log("Battle lost: your party is wiped.");
    endBattleToMap(false);
    return;
  }

  // if enemy party wiped -> victory
  if(unitsBySide(false).length===0){
    log("Battle won: enemy party wiped.");
    endBattleToMap(true);
    return;
  }

  // If enemy active died, auto-switch in renderBattleUI path; but handle explicitly:
  if(e && e.hp<=0){
    const aliveE = unitsBySide(false).filter(u=>u.id!==e.id);
    if(aliveE.length>0){
      game.battle.eActiveId = aliveE[0].id;
      log(`Enemy sends ${aliveE[0].name}.`);
    }
  }

  // If player active died, auto-switch to next alive
  if(p && p.hp<=0){
    const aliveP = unitsBySide(true).filter(u=>u.id!==p.id);
    if(aliveP.length>0){
      game.battle.pActiveId = aliveP[0].id;
      game.selectedUnitId = aliveP[0].id;
      log(`Auto-switch → ${aliveP[0].name} enters.`);
    }
  }

  renderBattleUI();

  // One battle exchange = consumes the turn, so advance global turn ONCE here if battle continues
  // (This preserves: game progresses only after player action.)
  // But: endBattleToMap already calls advanceTurn, so only do it if still in battle.
  if(game.phase==="battle"){
    // global tick: statuses/regen/upkeep continue while fighting
    tickStatusesGlobal();
    staminaRegenRule();
    territoryUpkeep();
    enemyActMap(); // enemies still pressure territory while you fight
    checkEnd();
    game.turn++;
    updateHUD();
    renderParty();
    draw();
    checkEvolutionPrompt();
  }
}

/* =========================================================
   Evolution UI
   ========================================================= */
function checkEvolutionPrompt(){
  if(game.phase==="deploy") return;
  if(game.phase==="battle") { $("#evoBox").classList.remove("active"); return; }

  const sel = game.units.find(u=>u.id===game.selectedUnitId);
  if(sel && sel.isPlayer && canEvolve(sel)){
    $("#evoBox").classList.add("active");
    const formNow = evoFormFor(sel);
    const nextStage = sel.evoStage + 1;
    const line = geneLine(sel.geneKey);
    const nextForm = line[nextStage-1];
    $("#evoHint").textContent =
      `${sel.name} (Lv ${sel.level}) can evolve: ${sel.geneKey} ${formNow.form} → ${nextForm.form}. Unlocks: ${(nextForm.unlock||[]).map(k=>MOVES[k]?.name||k).join(", ")||"none"}.`;
  } else {
    $("#evoBox").classList.remove("active");
  }
}

$("#btnEvolveNow").addEventListener("click", ()=>{
  const sel = game.units.find(u=>u.id===game.selectedUnitId);
  if(sel && sel.isPlayer){
    evolveUnit(sel);
    checkEvolutionPrompt();
  }
});
$("#btnEvolveLater").addEventListener("click", ()=>{
  $("#evoBox").classList.remove("active");
});

/* =========================================================
   HUD / Party
   ========================================================= */
function updateHUD(){
  $("#pillTurn").textContent = (game.phase==="play"||game.phase==="battle") ? String(game.turn) : "—";
  $("#pillMode").textContent =
    game.phase==="deploy" ? "Deploy" :
    game.phase==="battle" ? "Battle" :
    game.phase==="play" ? "Turns" :
    game.phase==="over" ? "Over" : "—";

  const counts = countTilesByVillage();
  const pKey = game.playerVillage?.key;
  const pTiles = pKey ? (counts[pKey]||0) : 0;
  $("#pillTiles").textContent = pKey ? `${pTiles}/64` : "—";

  if(game.playerVillage){
    $("#hudVillage").textContent = `${game.playerVillage.name} (${game.playerVillage.key})`;
    $("#hudClan").textContent = `${selection.clan.name} (${selection.clan.key})`;
    $("#hudGene").textContent = `${selection.gene.name} (${selection.gene.key})`;
  } else {
    $("#hudVillage").textContent = "—";
    $("#hudClan").textContent = "—";
    $("#hudGene").textContent = "—";
  }

  $("#hudTP").textContent = `${game.tech} / ${game.pop}`;
  $("#hudRes").textContent = `Food ${game.resources.food} • Ore ${game.resources.ore} • Relic ${game.resources.relic}`;

  const u = game.units.find(x=>x.id===game.selectedUnitId);
  if(u){
    $("#hudUnit").textContent = `${u.name} • Lv ${u.level} • ${u.geneKey} ${evoFormFor(u).form} • HP ${Math.ceil(u.hp)}/${u.maxHp} • STA ${u.sta}/8 • XP ${u.xp}/${u.nextXp}`;
  } else {
    $("#hudUnit").textContent = "—";
  }

  $("#hudWin").textContent = `Domination: ${RULES.dominationTiles} tiles OR Conquest: all enemy bases`;

  const badges = $("#miniBadges");
  badges.innerHTML = "";
  if(game.playerVillage){
    const mk = (txt, cls="")=>{
      const b=document.createElement("div");
      b.className="badge "+cls;
      b.textContent=txt;
      badges.appendChild(b);
    };
    mk(`Control: tiles 0–100`, "warn");
    mk(`Evolve: Lv 4 & Lv 8`, "good");
    mk(`Moves: stamina-cost`, "warn");
    mk(`Status: shield/bleed/stun`, "good");
  }
}

function renderParty(){
  const box = $("#partyBox");
  box.innerHTML = "";
  const team = game.units.filter(u=>u.isPlayer);
  for(const u of team){
    const div = document.createElement("div");
    div.className = "pchip" + (u.id===game.selectedUnitId ? " sel":"");
    const alive = u.hp>0;
    div.innerHTML = `
      <div style="font-weight:900;">${u.name} • Lv ${u.level} • ${u.geneKey} ${evoFormFor(u).form}</div>
      <small>HP ${Math.ceil(u.hp)}/${u.maxHp} • STA ${u.sta}/8 • XP ${u.xp}/${u.nextXp} • ${alive?"":"DOWN"}</small>
      <div style="margin-top:6px;" class="hpbar"><i style="width:${clamp((u.hp/u.maxHp)*100,0,100).toFixed(0)}%"></i></div>
    `;
    div.addEventListener("click", ()=>{
      if(u.hp<=0) return;
      if(game.phase==="battle"){
        // during battle, clicking switches (costs action)
        if(u.id!==game.battle.pActiveId){
          game.battle.pActiveId = u.id;
          game.selectedUnitId = u.id;
          log(`Switch → ${u.name} enters.`);
          battleEnemyRespond();
          battleAfterExchange();
        }
        return;
      }
      game.selectedUnitId = u.id;
      updateHUD(); draw(); renderParty(); checkEvolutionPrompt();
    });
    box.appendChild(div);
  }
}

/* =========================================================
   Rendering
   ========================================================= */
function cellToPixel(x,y){
  const s = TILE;
  return { px: PAD + x*s, py: PAD + y*s };
}
function pixelToCell(px,py){
  const s = TILE;
  const x = Math.floor((px - PAD)/s);
  const y = Math.floor((py - PAD)/s);
  return {x,y};
}
function resolveTileGlyph(type){
  if(type==="food") return "🍖";
  if(type==="ore") return "⛏";
  if(type==="relic") return "✦";
  if(type==="camp") return "⌂";
  return "";
}

function draw(){
  const w = canvas.width, h = canvas.height;
  ctx.clearRect(0,0,w,h);
  TILE = Math.floor((Math.min(w,h) - PAD*2) / SIZE);

  // grid
  ctx.save();
  ctx.globalAlpha = 0.12;
  ctx.strokeStyle = "white";
  for(let i=0;i<=SIZE;i++){
    const x = PAD + i*TILE;
    const y = PAD + i*TILE;
    ctx.beginPath(); ctx.moveTo(x,PAD); ctx.lineTo(x,PAD+SIZE*TILE); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(PAD,y); ctx.lineTo(PAD+SIZE*TILE,y); ctx.stroke();
  }
  ctx.restore();

  // tiles
  for(let y=0;y<SIZE;y++){
    for(let x=0;x<SIZE;x++){
      const t = tileAt(x,y);
      const {px,py} = cellToPixel(x,y);

      let base = "rgba(255,255,255,.03)";
      if(t.type==="food")  base = "rgba(52,211,153,.08)";
      if(t.type==="ore")   base = "rgba(251,191,36,.08)";
      if(t.type==="relic") base = "rgba(122,162,255,.08)";
      if(t.type==="camp")  base = "rgba(192,132,252,.09)";
      ctx.fillStyle = base;
      ctx.fillRect(px,py,TILE,TILE);

      if(t.owner){
        const v = game.villages.find(v=>v.key===t.owner);
        if(v){
          const u = (x+y)/(2*(SIZE-1));
          const col = gradColor(v.color, v.tone?.a ?? 0.14, v.tone?.b ?? 0.62, u);
          ctx.save();
          const alpha = 0.12 + 0.40*(clamp(t.control,0,100)/100);
          ctx.globalAlpha = alpha;
          ctx.fillStyle = col;
          ctx.fillRect(px,py,TILE,TILE);
          ctx.restore();
        }
      }

      if(t.owner && !t.baseOf){
        ctx.save();
        ctx.globalAlpha = 0.55;
        ctx.fillStyle = "rgba(255,255,255,.18)";
        ctx.fillRect(px+4, py+4, TILE-8, 5);
        ctx.fillStyle = "rgba(52,211,153,.75)";
        ctx.fillRect(px+4, py+4, (TILE-8)*(clamp(t.control,0,100)/100), 5);
        ctx.restore();
      }

      if(t.baseOf){
        ctx.save();
        ctx.globalAlpha = 0.90;
        ctx.fillStyle = "rgba(255,255,255,.75)";
        ctx.font = `${Math.max(12, Math.floor(TILE*0.20))}px ui-sans-serif, system-ui`;
        ctx.fillText("⛨", px+6, py+18);
        ctx.globalAlpha = 0.75;
        ctx.fillStyle = "rgba(255,255,255,.18)";
        ctx.fillRect(px+4, py+TILE-10, TILE-8, 6);
        ctx.fillStyle = "rgba(251,191,36,.85)";
        ctx.fillRect(px+4, py+TILE-10, (TILE-8)*(clamp(t.fort,0,RULES.baseFortHP)/RULES.baseFortHP), 6);
        ctx.restore();
      }

      const glyph = resolveTileGlyph(t.type);
      if(glyph){
        ctx.save();
        ctx.globalAlpha = 0.85;
        ctx.fillStyle = "rgba(232,238,255,.55)";
        ctx.font = `${Math.max(11, Math.floor(TILE*0.18))}px ui-sans-serif, system-ui`;
        ctx.fillText(glyph, px+6, py+20);
        ctx.restore();
      }
    }
  }

  // units
  for(const u of game.units){
    if(u.hp<=0) continue;
    if(!u.isPlayer && !villageAlive(u.villageKey)) continue;

    const v = game.villages.find(v=>v.key===u.villageKey);
    const {px,py} = cellToPixel(u.x,u.y);
    const cx = px + TILE*0.5;
    const cy = py + TILE*0.5;

    const uGrad = (u.x+u.y)/(2*(SIZE-1));
    const col = v ? gradColor(v.color, v.tone?.a ?? 0.14, v.tone?.b ?? 0.62, uGrad) : "#fff";
    const isSel = (u.id===game.selectedUnitId);
    const isActive = (game.phase==="battle" && (u.id===game.battle.pActiveId || u.id===game.battle.eActiveId));

    ctx.save();
    ctx.translate(cx,cy);

    if(u.isPlayer){
      ctx.fillStyle = col;
      ctx.fillRect(-TILE*0.22, -TILE*0.22, TILE*0.44, TILE*0.44);
      ctx.lineWidth = isActive ? 4 : (isSel ? 3 : 2);
      ctx.strokeStyle = isActive ? "rgba(251,191,36,.9)" : (isSel ? "rgba(52,211,153,.9)" : "rgba(255,255,255,.45)");
      ctx.strokeRect(-TILE*0.22, -TILE*0.22, TILE*0.44, TILE*0.44);
    } else {
      ctx.rotate(Math.PI/4);
      ctx.fillStyle = col;
      ctx.fillRect(-TILE*0.18, -TILE*0.18, TILE*0.36, TILE*0.36);
      ctx.lineWidth = isActive ? 4 : 2;
      ctx.strokeStyle = isActive ? "rgba(251,191,36,.9)" : "rgba(255,255,255,.45)";
      ctx.strokeRect(-TILE*0.18, -TILE*0.18, TILE*0.36, TILE*0.36);
    }
    ctx.restore();

    // label + hp bar
    ctx.save();
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = "rgba(232,238,255,.65)";
    ctx.font = `${Math.max(10, Math.floor(TILE*0.16))}px ui-sans-serif, system-ui`;
    ctx.fillText(`${u.name} Lv${u.level}`, px+4, py+TILE-6);

    const frac = clamp(u.hp/u.maxHp,0,1);
    ctx.globalAlpha = 0.8;
    ctx.fillStyle = "rgba(255,255,255,.15)";
    ctx.fillRect(px+4, py+4, TILE-8, 5);
    ctx.fillStyle = "rgba(52,211,153,.85)";
    ctx.fillRect(px+4, py+4, (TILE-8)*frac, 5);

    // shield pip
    if(u.status.shield>0){
      ctx.globalAlpha = 0.9;
      ctx.fillStyle = "rgba(122,162,255,.85)";
      ctx.fillRect(px+4, py+11, Math.min(TILE-8, 6 + u.status.shield*2), 4);
    }
    ctx.restore();
  }

  updateHUD();
}

window.addEventListener("resize", draw);

/* =========================================================
   Win / End
   ========================================================= */
function checkEnd(){
  const alivePlayers = game.units.filter(u=>u.isPlayer && u.hp>0).length;
  if(alivePlayers===0){
    game.phase="over";
    log("DEFEAT: all your units are down.");
    $("#battleBox").classList.remove("active");
    return;
  }

  const aliveEnemies = game.enemyVillages.filter(v=>v.alive).length;
  if(aliveEnemies===0 && game.enemyVillages.length>0){
    game.phase="over";
    log("VICTORY: all enemy bases eliminated.");
    $("#battleBox").classList.remove("active");
    return;
  }

  const counts = countTilesByVillage();
  const pTiles = counts[game.playerVillage?.key]||0;
  if(pTiles >= RULES.dominationTiles){
    game.phase="over";
    log(`VICTORY: domination achieved (${pTiles}/64 tiles).`);
    $("#battleBox").classList.remove("active");
  }
}

/* =========================================================
   Reset
   ========================================================= */
function hardReset(){
  selection.village=null; selection.clan=null; selection.gene=null;
  $("#btnVillageNext").disabled = true;
  $("#btnClanNext").disabled = true;
  $("#btnToDeploy").disabled = true;
  $("#pillBuild").textContent="—";
  $("#pillTurn").textContent="—";
  $("#pillMode").textContent="Draft";
  $("#pillTiles").textContent="—";
  $("#log").innerHTML="";
  $("#battleBox").classList.remove("active");
  $("#evoBox").classList.remove("active");

  renderGrid("#villageGrid", VILLAGES, null, pickVillage);
  setStage("#stage-village");
  log("Reset complete. Choose a new Village.");
}

(function boot(){
  updatePills();
  updateHUD();
  renderParty();
  draw();
})();
</script>
</body>
</html>
